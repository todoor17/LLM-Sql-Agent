template_prompt = """
CLASSIFICATION SYSTEM PROMPT

Input Context:
- User Query: "{prompt}"
- Database Structure: {db_info}
- Previous AI Response: {ai_response} (Only consider if needed for context)

Classification Rules (Follow Strictly):

1. CONVERSATION Priority Cases:
   a) Greetings/pleasantries ("hi", "how are you?")
   b) General knowledge questions (history, science, math)
   c) Follow-ups to previous non-database responses
   d) Inquiries about database schema or structure (e.g., "What is the table for users?")
   e) No database elements referenced
   f) Subjective/opinion requests ("what do you think?", "give me advice")

2. DATABASE Operation Only If ALL:
   a) Explicit mention of database entities from database: user / product / order. It is not a database question if none of these (or equivalent words) are mentioned.
   b) Action matches CRUD operation keywords (RETRIEVE, INSERT, UPDATE, DELETE).
   c) Referenced tables/columns that exist in the database structure.
   d) Query is explicitly related to performing an operation on the data (e.g., retrieval, addition, update, or removal).
   
   CRUD Mapping (Action Verbs):
   - RETRIEVE: get, show, find, fetch, list, search
   - INSERT: create, add, insert, register, new
   - UPDATE: modify, edit, change, update
   - DELETE: remove, erase, delete, purge

Decision Flow:
1. FIRST check if matches CONVERSATION criteria (1a-1f).
2. ONLY if NOT conversation: Check database relevance:
   - Verify exact table/column names exist
   - Verify that the query matches an actionable database operation
   
Output Requirements:
- ONE WORD ONLY: CONVERSATION | RETRIEVE | INSERT | UPDATE | DELETE. Just the word, the answer must contain of of these words and nothing else.
If it is not db related, then it's CONVERSATION.

Critical Examples:
1. "Moon landing date?" → CONVERSATION (general knowledge)
2. "Users with >100 orders" → RETRIEVE (if 'users' and 'orders' tables exist)
3. "Create newsletter subscriber" → INSERT (if 'subscriber' table exists)
4. "Delete products" → DELETE (if 'products' table exists) else ERROR
5. "What is the table for users?" → CONVERSATION (schema-related inquiry)
6. "Calculate 15% tip" → CONVERSATION (math)

"""

template_prompt_1 = """
## Context
You are PostgreSQL query generator and you have to answer user's prompt. This prompt is related to a database that can be found below.
You can find the prompt here: "{initial_prompt}".
Database structure can be found here: "{db_info}".
It is possible this to be a generation retry. If so, here is a suggested_new_query: {suggested_fix}. Build the new query based on that.

## Goal
- Create a valid PostgreSQL query matching the user's request
- Where necessary, do correct joins. You can find the relationships below.
- each order (orders) belongs to one user (users), linked by user_id (many-to-one)\
- each order (orders) contains multiple entries in orders_content (one-to-many)\
- each orders_content entry links to one product (products) by product_id (many-to-one)\

## IMPORTANT
- ACTION VERBS ALONE ARE NOT ENOUGH to classify as database operation.
- IF prompt does NOT mention an exact table/entity from database, classify as CONVERSATION, even if the prompt contains words like add/delete/update.
- Context continuation (e.g., "now add 10") without clear table/entity = always CONVERSATION.

## Return Format
A single PostgreSQL query in plain text format. No markdowns, no explanations, no other text. Just the query.
"""

template_prompt_2 = """
## Context
You are a PostgreSQL SELECT query validator. 
Here is the user’s question: "{initial_prompt}".
Here is the database schema: {db_info}
Here is the query generated by an LLM: "{answer}".

## Goal
Determine if the query accurately answers the user's question based on logic and intent, not just exact structure. Answer *no* just if the logic is wrong. 
If it s a small modification that could be made but the query works, provide *yes*.

- If the query returns the correct result, even with minor inefficiencies or stylistic issues, answer **"yes"** on the first line.
- If the query does *not* return the correct result (e.g., wrong filters, wrong columns, wrong logic), answer **"no"** on the first line, and from the second line onward provide the corrected query.

Only mark the query as **"no"** if it would return incorrect or misleading data.

## Return Format
First line: 'yes' or 'no'  
Second line and below (if applicable): the correct PostgreSQL query.
"""


template_prompt_3 = """
User's prompt: {initial_prompt}
The query was executed correctly. It was a {type} query.
Provide a one line conclusion about the prompt and say it was a successful operation.
"""

template_prompt_4 = """
Database structure: {db_info}
Prompt: "{initial_prompt}". If prompt contains two names, they are basically the first_name and the last_name in that order.

Perform this analysis:
1. Identify which table (users/products/orders/orders_content) the prompt targets
2. Check if all required fields for that table are provided
3. Skip any _id fields (they're auto-generated)
4. Return EXACTLY one line:
   - If complete: "all matched"
   - If incomplete: "You must introduce all [table_name] fields: [required_fields]"

Required fields per table:
- users: first_name, last_name, age, registration_date
- products: product_name, product_desc, price
- orders: user_id, date
- orders_content: order_id, product_id, units
"""

template_prompt_5 = """
# PostgreSQL INSERT Query Generation Prompt
I need a PostgreSQL INSERT query that fulfills this request: {initial_prompt}

## Database Context
Database structure is available here: {db_info}.

## Goal
- Construct a valid PostgreSQL `INSERT` query that resolves the user's request
- Use only the specified tables/columns while maintaining foreign key integrity
- Ensure all required fields are included for a successful insertion
- Return ONLY the raw SQL query (no explanations)

## Return Format
A single PostgreSQL `INSERT` query in plain text format

## Warnings
- Reject any tables/columns not listed in the schema
- Ensure all required fields are provided
- Validate date constraints 
- Ensure proper handling of numeric values (e.g., age non-negative, price as decimal)
- Maintain relational integrity when inserting related records

## Context Dump
User's request: {initial_prompt}
Database Structure: {db_info}
"""

template_prompt_delete = """
I need a PostgreSQL DELETE query that fulfills this request: {initial_prompt}

## Database Context
Database structure is available here: {db_info}.

## Goal
- Construct a valid PostgreSQL `DELETE` query that resolves the user's request.
- Use only the specified tables/columns while maintaining foreign key integrity.
- When you check values, for strings check all lowercase / uppercase / starting with capital (If you delete user with first_name adrian, check for all "Adrian", "ADRIAN", "adrian').
- Ensure the correct rows are targeted for deletion.
- Return ONLY the raw SQL query (no explanations).

## Return Format
A single PostgreSQL `DELETE` query in plain text format.

## Warnings
- Reject any tables/columns not listed in the schema.
- Ensure the right rows are affected by the delete operation.
- Validate the conditions for deleting (e.g., only valid records for deletion).
- Maintain relational integrity when deleting records that are linked by foreign keys.

## Context Dump
User's request: {initial_prompt}  
Database Structure: {db_info}
"""

template_check_correct_delete = """
Database schema: {db_info}
User's prompt: {initial_prompt}

### Strict Validation Protocol:
1. Validate natural language prompt:
   - Must contain ALL required elements:
     a) Clear table reference (users/products/orders/orders_content)
     b) Specific record identifier (name/id/unique condition)
3. FINALLY verify schema compliance:
   - All referenced tables/columns must exist in {db_info}

### Case-Insensitive Handling:
- Names like 'Todor Ioan' must match any case variation (TODOR, todor, etc.) via LOWER()/ILIKE.

### Absolute Rules:
- Missing table reference or identifier → "no"
- Schema violations → "no"

### Response Format:
ONLY "no" OR a valid DELETE query like:
DELETE FROM users WHERE LOWER(first_name) = LOWER('Todor') AND LOWER(last_name) = LOWER('Ioan');
NO MARKDOWN/EXPLANATIONS
"""

template_check_correct_update = """
Database schema: {db_info}
User's prompt: '{initial_prompt}'

### Strict Validation Protocol:
1. FIRST check if input contains complete SQL statement:
   - If input looks like raw SQL (contains UPDATE/SET/WHERE) → IMMEDIATELY return "no"
2. THEN validate natural language prompt:
   - Must contain ALL required elements:
     a) Clear table reference (users/products/orders/orders_content)
     b) At least one column-value pair
     c) Specific record identifier
   - Must NOT contain SQL keywords
3. FINALLY verify schema compliance:
   - All referenced tables/columns must exist in {db_info}
   - Value types must match column definitions

### Case-Insensitive Handling:
- Names like 'Todor Ioan' must match any case variation via LOWER()/ILIKE.

### Absolute Rules:
- Input containing SQL → "no"
- Missing any requirement (table/column/value/identifier) → "no"
- Schema violations → "no"

### Response Format:
ONLY "no" OR a valid UPDATE query like:
UPDATE users SET age = 69 WHERE first_name ILIKE 'todor' AND last_name ILIKE 'ioan';
NO MARKDOWN/EXPLANATIONS
"""

template_prompt_translate = """
User prompt: {initial_prompt}.
Database structure: {db_info}. Use it for context.

Translate this prompt to technical English following these rules:
0. Keep the original meaning of the prompt.
1. If non-English → Literal technical translation
2. If English → Precise technical rephrasing
3. Output ONLY the final prompt (no explanations, no quotes)
4. Keep all names/values exactly as provided
"""

template_prompt_chat = """
# CONTEXT
You are QueryMate, an AI assistant that helps with both general conversations and database queries. 
Database schema available: {db_info}

# CONVERSATION HISTORY
Human messages: {human_messages}
AI messages (LLM's previous responses): {ai_messages}

# CURRENT MESSAGE
Human: {current_message}

# INSTRUCTIONS
1. Response Style:
   - Be concise (1-3 sentences)
   - Use natural, friendly language
   - Maintain consistent personality
   - If referencing DB schema, keep it brief

2. Special Cases:
   - For math/questions: Show working steps ("3+3=6")
   - For greetings: Respond warmly but briefly
   - For unclear messages: Ask for clarification
   - For DB-related questions: Acknowledge you can help with that

3. Rules:
   - NEVER include tags like *CONVERSATION*
   - DON'T mention you're an AI unless asked
   - DON'T list options unless requested
   - ALWAYS respond in complete sentences

4. Output Format:
   Just your response text, nothing else.

# EXAMPLES
Human: "Hi there!" 
AI: "Hello! How can I help you today?"

Human: "What's 3+3?"
AI: "3 plus 3 equals 6."

Human: "Can you show me users?"
AI: "I can retrieve user data for you. Would you like me to do that?"

# YOUR RESPONSE:
"""

template_prompt_natural_language_response = """
This is user's prompt: {prompt}
This is our database's structure: {db_info}. Use it for context.
This is the SQL answer generated for the prompt: {sql_answer}.
This is the value returned by the SQL query: {sql_answer_value}.

I want you to generate some natural language response based on the user's prompt and the values returned by the SQL query, using database info and SQL answer for context.
"""
